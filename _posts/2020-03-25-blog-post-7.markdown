---
layout: post
title:  "Blog Post 7"
date:  2020-03-25 0:10:25 -0800
categories: jekyll blog
---
During spring break and the eighth week of class, I have focused my efforts on completing more question and answer modules in my attempt to pursue certification in Amazon Web Services (AWS) as well as working on the first lab available through the Vocareum portal. I also implemented certain Terraform resources for the group project. I also worked on the first available lab through the Vocareum portal. The parts that I have been able to cover so far includes the third and fourth modules which go over the AWS global infrastructure and cloud security. This progress builds upon the foundation I have previously established by completing the previous two modules. I watched a series of videos that related to each other by connecting to a centralized topic. After I viewed these online resources, I was then asked to answer multiple questions about the subjects mentioned in the videos. The inclusion of these questions was to test my understanding of each key area that was discussed and retain this knowledge for future use. To better acquaint myself with the AWS interface, I followed the detailed instructions that were explicitly listed within the first lab. They referred to Identity and Access Management (IAM) user accounts, different groupings of people, and various types of permission policy configurations that could be employed by the system. There are two kinds of policies that someone in the AWS management console could specify. The first are managed policies that have been preassembled or built to fit a certain user, group, or role. These permissions authorize an authenticated entity by allowing it to perform actions in the centralized hud that is the management console. While the managed policies are already considered to be prepackaged permissions that just need to be specified by the user, inline policies are otherwise known as custom solutions that apply only to single entities. They exist as single use features to be written off for single use occasions on a temporary basis. Both types of policies can be written in JSON code to specifically declare what resources to utilize in the console window. This perspective can breakdown the code even further for certain users who wish to view the finer details in the code and ensure their construction as tangible elements of cloud infrastructure. During my lab session, I processed the information and followed the listed instructions, but I would have liked it to have gone into more detail as to the nature of inline policies since I do not have any prior experience with JSON code. In addition, I didn't see how such a policy was created in the console even though I understand its purpose. This is because it was already established as a defined option when I started the online lab. 

Furthermore, I tried to work on my Terraform code for the group project. My group has decided to form a dedicated CI\CD code pipeline in the AWS management console using Terraform code and some other readily available resources. We plan to connect this pipeline to a custom-made website best suited for this project. So far, our overall solution appears to be progressing slowly and requires more attention as to ensure its completion by the end of the semester. At first I attempted to construct a CodeCommit data repository inside the console as to get a better understanding of how this particular resource works and performs operations, however, it was not as clear cut as I initially believed since the provided AWs documentation on this subject referred to several different webpages and sometimes I felt like I was going in circles. To gain my bearings of the situation, I created a blank text file as to write my notes and proceed towards my goal. Eventually I was able to arrange a sort of chronological guide that was composed of a number of links to separate webpages that could help me. The information that was recorded on these pages assisted me in constructing the repository, and in time I was able to push and pull data from it as well. I had greater difficulty moving this data around than I did creating the repository since there were a few webpages that seemed to offer conflicting advice in terms of contradictory Linux terminal commands. I feel that my understanding of what the CodeCommit resource is used for is fine, but the process of assembling it and how it operates seems shakier to me due to the obscurity of the source material and my inexperience. I am hoping the guide of references I made will help me with these two areas. After briefly practicing in the console, I moved on to my Terraform code that is stored in my Ubuntu virtual machine. I crafted code that formed resources such as an S3 bucket, Dyanmodb table, and an empty CodeCommit data repository in the console. This code seems to work properly and does not generate any overt error messages that would interfere with the established cloud infrastructure, but when I add code that is specifically designed to add the codepipeline portion of the project, it immediately fails to compile and states that there is something wrong with several undeclared resources in the root module. I do not know what might be causing this error since I am not using any modules to organize my code, and the two examples I have found seem to be informative on the matter. The code listed in the Terraform documentation and on the Medium website are the primary examples I have been following as potential guides. I have tried rearranging certain aspects of my code to see if that would improve it, but this change had no effect on the output since it remains the same. The information presented in the source material does not seem to differ too much, but it appears to produce the same results. I am currently stumped as to what is the issue with my code. I will try reaching out for help, so I can get these parts operational in the console. 

